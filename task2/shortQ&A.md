## 简答题
第一题：a[6]() // 10 都是在数组中创建10个Fuction, 但是var的写法是全局作用域，如果想要输出1-10把for循环的var 变成let 就可以了

第二题：ReferenceError: temp is not defined；如果去掉 if(true){} temp重复定义 也是作用域的问题

第三题：(arr.sort((a , b) => a - b))[0]

第四题：var js模块全局作用域，可以修改。let,const都是es6出来的完善作用域的，const 不可更改 let 可以更改

第五题：this.a = 20 // this指向的obj, 哪个调用，this就是指向谁


第六题：Symbol类型的用途
-----------------------
主要是为了对象key值得唯一性，工作中没怎么用过。 


第七题：说说浅拷贝和深拷贝
-----------------------
浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，所以新引用值修改也会影响到之前的value，而深复制则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。深拷贝的方法主要有2种，一个是递归赋值，第二种是JSON.stringify,JSON.parse 但是在function和undefined上有bug

第八题 简述ts和js 的关系
--------------------------
TS是JS的超集，js 是传统的弱类型语言。浏览器只认识js，所以还需要bable转义；常见的组件开发，和公共库开发可以使用ts，明确funtion传参的类型，但是业务页面开发时候会多出很多type 和 interface。增加开发工作量

第九题：ts有优缺点
-----------------
优点：类型定义更明确，可以减少开发时候的类型传参错误；api提示，更方便文档阅读
缺点：复杂的业务页面，写起来比较累

第十题：引用计数的原理和优缺点
--------------------
原理：引用计数用来记录当前有多少指针指向同一块动态分配的内存。当有指针指向这块内存时，计数器加1；当指向此内存的指针销毁时，计数器减1。当引用计数为0时，表示此块内存没有被任何指针指向，此块被共享的动态内存才能被释放。
优缺点：相互引用的时候无法回收

第十一题：引用计数的工作流程
--------------------
引用计数的含义是跟踪记录每
个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。
如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取
得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这
个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那
些引用次数为零的值所占用的内存。

第十二题：V8新生代存储区垃圾回收的流程
---------------------------
首先将From空间中所有能从根对象到达的对象复制到To区，然后维护两个To区的指针scanPtr和allocationPtr，分别指向即将扫描的活跃对象和即将为新对象分配内存的地方，开始循环。循环的每一轮会查找当前scanPtr所指向的对象，确定对象内部的每个指针指向哪里。如果指向老生代我们就不必考虑它了。如果指向From区，我们就需要把这个所指向的对象从From区复制到To区，具体复制的位置就是allocationPtr所指向的位置。复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址，并移动allocationPtr。如果一个对象内部的所有指针都被处理完，scanPtr就会向前移动，进入下一个循环。若scanPtr和allocationPtr相遇，则说明所有的对象都已被复制完，From区剩下的都可以被视为垃圾，可以进行清理了

第十三题：增量标记算法何时使用及工作原理
---------------------------
它是在V8清除老生代对象时为提高清除效率优化时使用的，因为在进行垃圾回收的操作时会阻塞程序的执行，所以在老生代中会在程序执行的空档期去执行回收操作，此时就可以使用增量标记算法。它是将当前一整段的垃圾回收操作，分成多个小步组合去完成，实现垃圾回收和程序执行交替完成，可以让时间消耗更合理，达到效率优化的好处

原理：
1.JS程序执行过程中，会伴随着垃圾回收的工作
             2.当垃圾回收工作时，需要遍历对象进行标记，此时不需要将所有对象进行标记，可以先将直接可达的对象进行标记，标记完成后暂停标记
             3.然后让JS程序执行一会，再让GC机制去做二步标记，将间接可达的对象进行标记，标记完成后暂停标记
             4.重复以上两不操作，让程序执行和垃圾回收的标记操作交替执行，来达到优化效率和提升用户体验的目的
             5.直到标记全部完成后，执行垃圾回收



 


